\chapter{Aspects of Rule-Based Systems}\label{ch:aspects-of-rule-based-systems}

Rule-based systems, often encountered in the fields of artificial intelligence and computer science,
are systems that apply predefined rules to a given problem or dataset
and derive conclusions or make decisions based on the input data\cite{grosan2011rule}.

Deriving conclusions requires expert knowledge in the respective domain.
The main difference to an ordinary software system is that the system does not hard-cde the domain-specific knowledge.
Instead, we have rules that encode domain knowledge in a predefined rule language.
The system treats these rules as an external resource and loads them into a rule-base.
It directly uses the rule-encoded knowledge found in the rule-base to derive conclusions.
A rule-based systems is therefore a framework for knowledge experts that do not need to have a technical background.
However, users must possess the requisite skill to translate their expert knowledge into rules,
which requires them to have a profound understanding of the rule language.


These rules are typically explicit,
declarative and logical statements about specific conditions that must hold to make the system act in a specific way.
Rule-based systems are inherently knowledge-intensive applications\cite{hayes1985rule}.
Their performance heavily relies on the quality,
depth and richness of the domain-specific knowledge encoded in its rules.
Rules in a rule-based system have the following form:

\[
    \text{<Rule-id>}: \text{IF} \text{<condition>} \text{THEN} \text{<conclusion>} \text{holds}
\]


A rule consists of a \textbf{condition} and a \textbf{conclusion}
and makes the rule-based system apply the conclusion if the condition holds.
Its purely logical and declarative nature and makes them explicit, deterministic and predictable.
Each rule has an identifier that makes it unique among the set of all rules in the system.

However, due to their simplicity, they also come with some limitations.
They lack the ability to learn from new data autonomously and new rules to be added manually.
Domain knowledge can also change which requires domain experts to be responsible for maintenance and rule updates.
Knowledge domains can also be highly complex.
High complexities increase the number of rules that a rule-based system requires to work effectively in production.


\section{Rule Language Requirements}

Rule-based systems do not require


\begin{itemize}
    \item Clearly defined syntax and semantics.
    \item User-friendliness
    \item Satisfactory expressiveness for all concrete cases
    \item Rule base should be easy to extend
    \item Rule language should be updatable
\end{itemize}

As every domain-specific language, a rule language needs clearly defined semantics and syntax.


Finding the correct compromise between language expressiveness and user-friendliness\cite{https://doi.org/10.1002/widm.11} requires careful consideration.
On one side,
the language needs
to be sufficiently powerful to articulate all conditional logics and edge cases that may occur in the knowledge domain.
On the other side, the language must remain accessible to domain experts that will finally implement rules.
For the language to remain relevant and effective, it should adapt over time, incorporating feedback from its user base.
This might involve introducing new constructs or syntactic sugar to simplify common tasks.





Possible rule strategies:

<Rule-id>: IF <condition> THEN <conclusion>

A rule-based system to work its rule base needs
to contain a high number of valid rules that incorporate large parts of the respective knowledge domain.
For the sake of transparency every rule needs an id that identifies holding rules in an evaluated result set.

A condition is essentially a function which the rule engine can.

\[
    \text{conclusion holds} \Leftrightarrow f(\text{input1}, \text{input2}, \ldots, \text{input3}) = \text{true}
\]

\section{Inference Mechanism}

Basically, there are two modes of inference mechanisms\cite{https://doi.org/10.1002/widm.11}

\begin{itemize}
    \item forward chaining
    \item backward chaining
\end{itemize}


Forward chaining is an inference strategy where reasoning begins with the existing facts.
The inference engine simply applies the conditions of all rules in the rule base to the known data.
Finally,
we add the conclusions of those rules
whose conditions hold to the set of valid conclusions and thus to the set of facts.

Backward chaining uses a different strategy\cite{al2015comparison}.
The user specifies a single goal or hypothesis
which we want to proof or reject and looks for rules in the rule base whose conclusion would match with it.
The conditions of those rules are now the new goal which the system needs to satisfy.
The system then recursively looks for rules with matching conclusion
and tries to satisfy their conditions as new sub-goals.
If the system is able to reduce all sub-goals to facts, we accept the initial hypothesis.
If the system cannot find further rules, we reject the initial hypothesis.
This inference strategy is often used in diagnostics and decision support\cite{https://doi.org/10.1002/widm.11}

Part of the design of the rule-based framework in this work is the decision between forward and backward chaining.
Chapter \section{sec:rule-core} revisits this design decision
and provides a more detailed justification for the choice taken.
