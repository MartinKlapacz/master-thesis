\chapter{Aspects of Rule-Based Systems}\label{ch:aspects-of-rule-based-systems}

Components of a rule-based System:

\begin{itemize}
    \item Rule Base: A pool of known valid rules
    \item Inference Engine
    \item
\end{itemize}


Rules have the following form:

<rule-id>: IF <condition> THEN <conclusion> holds


\section{Inference Mechanism}

Basically, there are two modes of inference mechanisms\cite{https://doi.org/10.1002/widm.11}

\begin{itemize}
    \item forward chaining
    \item backward chaining
\end{itemize}


Forward chaining is an inference strategy where reasoning begins with the existing facts.
The inference engine simply applies the conditions of all rules in the rule base to the known data.
Finally, we add the conclusions of those rules whose conditions hold to the set of valid conclusions and thus to the set of facts.

Backward chaining uses a different strategy\cite{al2015comparison}.
The user specifies a single goal or hypothesis which we want to proof or reject and looks for rules in the rule base whose conclusion would match with it.
The conditions of those rules are now the new goal which the system needs to satisfy.
The system then recursively looks for rules with matching conclusion and tries to satisfy their conditions as new sub-goals.
If the system is able to reduce all sub-goals to facts, we accept the initial hypothesis.
If the system cannot find further rules, we reject the initial hypothesis.
This inference strategy is often used in diagnostics and decision support\cite{https://doi.org/10.1002/widm.11}

Part of the design of the rule-based framework in this work is the decision between forward and backward chaining.
Chapter \section{sec:rule-core} revisits this design decision and provides a more detailed justification for the choice taken.


\section{Requirements}

\begin{itemize}
    \item Clearly defined syntax and semantics
    \item Satisfactory expressiveness for the use case
    \item User-friendliness
    \item Rule base should be easy to extend
    \item Rule language should be updatable
\end{itemize}

As every domain-specific language, a rule language needs clearly defined semantics and syntax.


An issue that requires careful consideration is to find the correct compromise between language expressiveness and user-friendliness\cite{https://doi.org/10.1002/widm.11}.
On one side, the language needs to be sufficiently powerful to articulate all conditional logics that may occur in the knowledge domain.
On the other side, the language must remain accessible to domain experts that will finally implement rules for the rule-based system.

depending on the background of the knowledge engineers that will finally use the rule framework to write rules .


Part of the design of a domain specific rule language is to find the correct



possible rule strategies:

<rule-id>: IF <condition> THEN <conclusion>

A rule-based system to work its rule base needs to contain a high number of valid rules that incorporate large parts of the respective knowledge domain.
For the sake of transparency every rule needs an id that identifies holding rules in an evaluated result set.

A condition is essentially a function which the rule engine can.

\[
    \text{conclusion holds} \Leftrightarrow f(\text{input1}, \text{input2}, \ldots, \text{input3}) = \text{true}
\]





\section{General Structure}




\section{Requirements}


