\section{The Code Derivation Pipeline}\label{sec:the-code-derivation-pipeline}





The following condition fields cause post-derivation code conflicts:
\begin{itemize}
    \item \code{excludedTargetCodes}: This condition causes conflicts the conclusion code of the rule and all codes
    \item \code{isSingleBillingPosition}: this condition causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
    \item \code{isSingleBillingPositionIfPractitionerIsDoctor}: This condition also causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
\end{itemize}

\subsection{Rule Evaluation Stage}\label{subsec:rule-evaluation-stage}

The system distinguished between rule types.
Section \addref lists the currently supported rule types.



\subsection{Rule Evaluation Rounds}\label{subsec:rule-evaluation-rounds}

A fundamental framework characteristic is that it evaluates each rule independently of any other rule.
It happens completely isolated from the rest of all rules.
The only dynamic environment for rule evaluations is the \REI object.

Section \addref, however, introduces the \code{requiredTargetCodes} condition type.
To evaluate this condition, the system needs the final result set.
At this initial stage, this information is not available, because the final result set is yet currently being computed.

To solve this issue, I modified the derivation process by introducing multiple rounds where we evaluate all rules of that rule type.
After each round, we manually update the \code{currentTargetCodes} field with the recently computed result.
The \code{requiredTargetCodes} condition uses the codes in \code{currentTargetCodes} to evaluate itself.
We interrupt the loop when there are no further changes in \code{currentTargetCodes}.
This way we always have at least two rule evaluation rounds, but are able to derive codes with arbitrarily long \code{requiredTargetCodes} dependency chains.



\subsection{Conflict Resolution}

The following condition fields cause post-derivation code conflicts:
\begin{itemize}
    \item \code{excludedTargetCodes}: This condition causes conflicts the conclusion code of the rule and all codes
    \item \code{isSingleBillingPosition}: this condition causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
    \item \code{isSingleBillingPositionIfPractitionerIsDoctor}: This condition also causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
\end{itemize}

The issue is that the framework evaluates each rule independently.
Each rule evaluation happens isolated from the rest of all rules.


\section*{Maximum Weight Independent Set Problem}

Given a graph $G = (V, E)$ with vertex set $V$ and edge set $E$, and a weight function $w: V \rightarrow \mathbb{R}$ that assigns a weight to each vertex, the Maximum Weight Independent Set problem seeks to find an independent set $S \subseteq V$ that maximizes the total weight. An independent set is a set of vertices in the graph, no two of which are adjacent. Formally, the problem can be stated as:

\begin{equation}
    \begin{aligned}
        & \text{Maximize}
        & & \sum_{v \in S} w(v) \\
        & \text{subject to}
        & & S \subseteq V, \\
        &&& \forall (u, v) \in E, \; u \notin S \text{ or } v \notin S.
    \end{aligned}
\end{equation}



