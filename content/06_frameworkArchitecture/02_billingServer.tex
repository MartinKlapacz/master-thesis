\section{Billing server}\label{sec:billing-server}
The billing server is a new microservice added to the microservice architecture of \AV.
It contains most parts of the billing framework implemented in this work.
It implements the derivation pipelines described in section \ref{sec:the-code-derivation-pipeline-for-statutory-treatments}
and \ref{sec:the-code-derivation-pipeline-for-private-treatments}
as well as the rule language as specified in section \ref{sec:rule-language-specification}.

\lstinputlisting[
    language=protobuf2,
    style=protobuf,
    caption={Code Derivation API of the Billing Server}
]{code/proto/architecture/code-derivation.proto}

The \code{CodeDerivationService} gRPC service of the billing server exposes endpoints for code derivation and validation for specific treatments.
It also allows deriving OPS codes, EBM flatrates and multiplier justifications.

A \code{DeriveCodesResponse} contains actual billing codes mapped to their quantity.
Other services can use \code{validateEbmCodes} and \code{validateGoaeCodes} to check if a set of codes are applicable for a specific treatment.
They respond with a \code{CodeValidationResponse} which, if present, contains explanatory information about existing conflicts.

Besides automatic rule derivation, it exposes gRPC endpoints for CRUD operations on billing positions, billing cases, code chains and code chain folders.
These endpoints are necessary for manual and conventional billing creation.
It exposes endpoints for receiving and storing rules and catalogs used by the clients described in section \ref{sec:rule-file-repository}.


\subsection{Rule Evaluation Input Fetcher}\label{subsec:rule-evaluation-input-fetcher}
A \code{RuleEvaluationInputFetcher} is a rule-type specific component responsible for fetching billing-relevant information from other \AV microservices.
They are auto-programmable components that hide fetching details from the rest of the system.
The term \"auto-programmable\" means that they configure themselves automatically upon rule loading.
This works as follows: The \code{Rule} entity class has as described before multiple condition fields.
The condition field names are equal to their corresponding condition keys in the rule language.
As described in \addref Each condition field subscribes to one or more information sources.
Each information source lives as a custom java annotation in the billing server.
To distinguish those custom annotation types from unrelated annotations, they are again annotated with \code{@InformationSource}.
Condition fields inside the \code{Rule} entity class are decorated with annotations for the information sources they subscribe to.
Upon receiving all rules of a rule type, a rule type specific \code{RuleEvaluationFetcher} scans those rules.
It collects all \code{@InformationSource} annotated annotations of any non-null condition field in any received rule of that rule type in a hashset.
For each derivation call, the respective \code{RuleEvaluationFetcher} instance executes the fetch implementations of its collected information source annotations.
Finally, it populates a \code{RuleEvaluationInput} instance with its received data and returns it.

\subsection{Rule Component}\label{subsec:rule-component}

