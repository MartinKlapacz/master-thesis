\section{The Code Derivation Pipeline for Private Treatments}\label{sec:the-code-derivation-pipeline-for-private-treatments}

The following condition fields cause post-derivation code conflicts:
\begin{itemize}
    \item \code{excludedTargetCodes}: This condition causes conflicts the conclusion code of the rule and all codes
    \item \code{isSingleBillingPosition}: this condition causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
    \item \code{isSingleBillingPositionIfPractitionerIsDoctor}: This condition also causes conflicts between the respective code and the rest of the codes causing a star-topology conflict graph
\end{itemize}

\subsection{Rule Evaluation Stage}\label{subsec:rule-evaluation-stage}

The system distinguished between rule types.
Section \addref lists the currently supported rule types.

\subsection{Rule Evaluation Rounds}\label{subsec:rule-evaluation-rounds}

A fundamental framework characteristic is that it evaluates each rule independently of any other rule.
At this stage each rule evaluation is completely isolated from any other rule.
The only  environment for rule evaluations is the \REI object.

Section \addref, however, introduces the \code{requiredTargetCodes} condition type.
To evaluate this condition, the system needs the final result set.
At this initial stage, this information is not available, because the final result set is yet currently being computed.
To solve this issue, I modified the derivation process by introducing subsequent rounds where we evaluate all rules of that rule type.
After each round, we manually update the \code{currentTargetCodes} field in the \REI with the recently computed result.
The \code{requiredTargetCodes} condition uses the codes in \code{currentTargetCodes} to evaluate itself.
We interrupt the loop when there are no further changes in the result set.
This way we always have at least two rule evaluation rounds, but are able to derive codes with arbitrarily long \code{requiredTargetCodes} dependency chains.

\subsection{Conflict Resolution}

\code{requiredTargetCodes} is not the only condition type that requires special handling.
The following condition fields also require the full derivation result for their evaluation.
\begin{enumerate}
    \item The condition field \code{excludedCodes: List<String>} causes conflicts between the conclusion code and all nodes inside the list value of \code{excludedCodes}
    \item The GOÃ„ catalog specifies code exclusions in a structured way.
    This is equivalent to the \code{excludedCodes} condition field.
    \item The condition field \code{isSingleBillingCondition: Boolean} causes conflicts between the respective code and all other codes in the result set
    \item The condition field \code{isSingleBillingConditionIfPractitionerIsDoctor: Boolean} causes conflicts between the respective code and all other codes in the result set
\end{enumerate}
Unlike \code{requiredTargetCodes} they cause post-derivation code conflicts within the derivation set.
This has a fundamental impact on the derivation pipeline.
Instead of a set of applicable codes, the result type of the initial and subsequent rule evaluation rounds is a graph.
Each node in this graph is a derived code.
A conflict between two codes is an edge between the corresponding two nodes.
In the PVS seminar, I have learned that resolving these conflicts manually by hand is common practice for medical staff.
Billing experts typically eliminate conflicting nodes while trying to keep the fee loss as small as possible.
From a theoretical point of view, this is graph optimization problem called the Maximum Weight Independent Set problem (MWIS) \cite{SAKAI2003313}.
Solving such problems automatically is the last step in the derivation pipeline and required the selection and implementation of an appropriate solver algorithm.
Before formalizing the problem and presenting the selected solver we firstly state and justify assumptions about the problems that will occurr in practice.

\begin{itemize}
    \item The occurring MWIS problems are comparably simple.
    This is inherently the case because in traditional medical billing, medical staff resolves those conflict issues by hand.
    The majority of the nodes are unlikely to be involved in conflict at all.
    This means that most nodes in an average result graph are remote nodes the solver can effectively ignore.
    \item Star topology sub-graphs are comparably likely.
    A code being the conclusion of a rule with a condition \code{\{ isSingleBillingCondition: true \}} introduces conflicts with all other nodes in the graph.
    The actual implementation in the framework should be able to handle those types of graphs very well.
    \item The number of edge conflicts will be very low.
    This is due to the reason that codes that explicetly exclude themselves using the \code{excludedTargetCodes} condition type also logically exclude themselves.
    This means that
\end{itemize}

\subsection{Maximum Weight Independent Set problem}\label{subsec:maximum-weight-independent-set-problem}

The Maximum Weight Independent Set problem (MWIS) is a well studied and highly important problem in the field of graph optimization.
Its formal definition is as follows \cite{SAKAI2003313}:
Given a graph $G = (V, E)$ with node set $V$ and edge set $E$, and a weight function $w: V \rightarrow \mathbb{R}$ that assigns a weight to each node, the Maximum Weight Independent Set problem seeks to find an independent set $S \subseteq V$ that maximizes the total weight.
An independent set is a set of vertices in the graph, no two of which are adjacent.
Formally, the problem can be stated as:

\begin{equation}
    \begin{aligned}
        & \text{Maximize}
        & & \sum_{v \in S} w(v) \\
        & \text{subject to}
        & & S \subseteq V, \\
        &&& \forall (u, v) \in E, \; u \notin S \text{ or } v \notin S.
    \end{aligned}\label{eq:mwis}
\end{equation}

The weight function $w$ assigns the fee to the billing code.

%For private billing $w$ is defined as follows:
%\begin{equation}
%    w\left(c\right) = p\left(c\right) \times \text{multiplier} + \text{flatrate}\label{eq:fee-function}
%\end{equation}



\paragraph{GWMin}
GWMin starts up from an empty node set and iteratively adds the node $v_i$ with the currently optimal relation between weight $w(v_i)$ and degree $d(v_i)$ \cite{SAKAI2003313}.
The node selection can be formulated as the following optimization problem:
Given a graph $G = (V, E)$ with a weight function $W: V \to \mathbb{R}_{\geq 0}$ it selects the next node as follows :
\[
    v' = \max_{v \in V'} \frac{W(v)}{\deg(v) + 1}
\]
where $V'$ is the set of nodes not yet included in the independent set and not adjacent to any node in the current independent set.


\begin{algorithm}
    \caption{GWMIN Algorithm}
    \begin{algorithmic}[1]
        \Procedure{GWMIN}{$G(V, E, W)$}
            \State $I \gets \emptyset$ \Comment{Initialize independent set}
            \State $V' \gets V$ \Comment{Copy of the node set}
            \While{$V' \neq \emptyset$}
                \State $u \gets$ \Call{Selectnode}{$V', G, W$}
                \State $I \gets I \cup \{u\}$ \Comment{Add selected node to independent set}
                \State $V' \gets V' \setminus \{u\}$ \Comment{Remove selected node}
                \State $V' \gets V' \setminus$ Neighbors$(u, G)$ \Comment{Remove neighbors}
            \EndWhile
            \State \textbf{return} $I$
        \EndProcedure
    \end{algorithmic}\label{alg:algorithm-gwmin}
\end{algorithm}

The selection procedure works as follows:

\begin{algorithm}
    \caption{GWMIN Algorithm}
    \begin{algorithmic}[1]
        \Procedure{Selectnode}{$V', G, W$}
            \State $selected \gets$ null
            \State $maxScore \gets -\infty$
            \For{$v \in V'$}
                \State $score \gets W(v) / (\text{Degree}(v, G) + 1)$
                \If{$score > maxScore$}
                    \State $maxScore \gets score$
                    \State $selected \gets v$
                \EndIf
            \EndFor
            \State \textbf{return} $selected$
        \EndProcedure
    \end{algorithmic}\label{alg:algorithm-gwin-selection}
\end{algorithm}


\paragraph{GWMin2}
GWMin2 is a modified version of the GWMin algorithm with another node selection strategy \cite{SAKAI2003313}.
It selects the next node as follows:
\[
    v' = \max_{v \in V'} \frac{W(v)^2}{\sum_{u \in N_G^+(v)} W(u)}
\]
It focuses on maximizing the ratio of the square of a node's weight $w\left(v\right)^2$ to the sum of the weights of all vertices in its neighborhood $N\left(v\right)$.


